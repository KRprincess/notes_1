## C++
### 1. const和static的用法实例
```
class Test
{
public:
      Test():a(0){}
      enum {size1=100,size2=200};
private:
      const int a;//只能在构造函数初始化列表中初始化
       static int b;//在类的实现文件中定义并初始化
      const static int c;//与 static const int c;相同。
};

int Test::b=0;//static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象。
const int Test::c=0;//注意：给静态成员变量赋值时，不需要加static修饰符。但要加const
```

### 2.exe运行时VCRUNTIME140*.DLL找不到，为什么？
参考：https://ugetfix.com/ask/how-to-fix-vcruntime140-dll-is-missing-error-on-windows/

### 3.‘class’类型重定义
问题原因：头文件被多次引用、编译。<br>
解决方法：在.h文件头添加
```
#ifndefine XX_H 
#define XX_H //确保上下名字一致，不要粗心写错了！！！
#endif
 ```
或`#pragma once`保证头文件被编译一次

### 4. 析构函数什么调用？
- 本地变量：离开函数时
- 全局变量：程序结束时
- `new`对象：`delete`时

**note:** `vector`用`erase`删除元素,在删除元素之前，析构函数被调用

### 5. map与unordered_map
- map:
 <br>(1)底层数据结构是rb_tree;
 <br>(2)查找速度是log(n)级别;

- unordered_map:
 <br>(1)底层数据结构是hash table;
 <br>(2)unordered_map就是hash_map， 查找速度会比map快，而且查找速度基本和数据量大小无关，属于常数级别;

 **note:**
 - Red_Black tree是平衡二分搜寻树(balanced binary search tree),它是高度平衡的二叉树,这样有利于search和insert.
   <br>rb_tree是关联式容器`map`和`set`的底层实现
- hash还有hash函数的耗时。当有100w条记录的时候，map也只需要20次的比较，200w也只需要21次的比较！所以并不一定常数就比log(n) 小.

### 6.类的静态成员变量 class-wide
 <br>(1) hidden:遵循一般的访问规则
 <br>(2) persistent:相当于全局变量，独立于对象（independent of instance），所有的对象保持一致
 <br>(3) 在头文件类的声明里面，静态成员变量只表示声明，即在某处存在该变量的定义，具体在哪里不知道。所以，在.cpp文件里面必须对其进行定义。
 <br>(4) 不能在初始化列表中初始化

### 7.类的静态成员函数
<br>只能访问类的静态成员变量
<br>不能使用this指针，因为this表示调用这个函数的那个对象，static又是独立与对象的。
```
Class A
{
       public:
              A(){i=0}
              void print(){cout<<i<<endl;}
              void set(int i){this->i=i;}
              static void say(){cout<<i<<endl;}
       private:
              int k;
              static int i;
}

int A::i=20;
int main()
{
       A a,b;

       a.set(10);
       b.print();

       a.say();
       A::say();

       cout<<A::i<<endl;

       return 0;
}
```

### 8. 为什么不能cout一个string
想使用operator<<需手动包含<string>头文件
<br>仅通过对<iostream>文件的包含，我们即可使用string和ostringstream等类，然而当我们想使用其成员函数时，需要包含其最终的实现版。`#include<sstream>`

### 9. 如何理解.h文件和.cpp文件
https://blog.csdn.net/sinat_36053757/article/details/64444556

### 10. 预处理（preprocessing）->编译（compilation）->汇编（assembly）->链接（linking）->执行（execution）
- 预处理/预编译(`->.i`)：gcc例子`gcc –E hello.c –o hello.i`
<br>预处理器在程序编译之前，将源程序中的宏定义、条件编译、头文件（源代码文件以“#”开始的预编译指令。比如“#include”、“#define”和条件预编译指令，如“#if”、“#ifdef”等。）包含指令以及特殊符号完成相应的替换工作(将所有的“#define”删除，展开所有的宏定义，并且替换掉“#include”。)。
<br> <1> 经过预处理后的程序，生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件。这些输出文件的含义与没有经过预处理的源文件是相同的，但内容有所不同
<br> <2>预编译头，就是把一个工程中要使用的一些标准头文件预先编译，以后该工程编译时，不再编译这部分头文件，仅仅使用预编译的结果。这样可以加快编译速度，节省时间。
<br>关于预编译头文件：
<br>预编译头文件通过编译`stdafx.cpp`生成，以工程名命名，由于预编译的头文件的后缀是“pch”，所以编译结果文件是`projectname.pch`。
<br>编译器通过一个头文件`stdafx.h`来使用预编译头文件。
<br>stdafx.h这个头文件名是可以在project的编译设置里指定的。
<br>编译器认为，所有在指令`#include "stdafx.h"`前的代码都是预编译的，它跳过#include "stdafx. h"指令，使用projectname.pch编译这条指令之后的所有代码。
<br>代码文件第一条语句都是：#include "stdafx.h"。在它前面的所有代码将被忽略，所以其他的头文件应该在这一行后面被包含

- 编译程序（`.i->.s`）：gcc例子`gcc -S hello.i -o hello.s`
<br>以预编译的输出作为输入，利用c++运行库，通过词法分析和语法分析，在确认所有指令都符合语法规则的情况时，将其翻译成等价的中间代码表示或汇编语言。 
<br>**编译是以源程序文件为单位单别编译的，头文件不参加编译。**

- 优化程序：
<br>一是对中间代码的优化，这种优化不依赖具体的计算机，同机器的硬件环境无关。主要的工作是删除公共表达式、循环优化(循环展开，自动向量化、循环不变量代码移动)以及无用赋值的删除等。
<br>另一种则主要针对目标代码的生成而进行的优化。此种优化同机器的硬件结构密切相关。最主要的是考虑如何充分利用机器的各个硬件寄存器存放有关的变量的值，以减少对于内存的访问次数

- 汇编程序(`.s->.obj`)：gcc例子`gcc –c hello.s –o hello.o`
<br>将编译、优化后的以汇编语言存在的程序转化为机器可识别的二进制代码，从而得到相应的目标文件（后缀`.obj`，不可执行）。目标文件通常由数据段和代码段组成。
<br>代码段保存的是程序的指令，该段一般是可读和可执行的，但一般是不可写的。
<br>数据段主要用来保存程序中所定义的或者需要用到的**全局变量、静态数据**(局部变量是在运行阶段生成)。数据段一般是可读可写的.

- 链接程序(`.obj->.exe`)：gcc例子`gcc hello.c -o hello.exe`
<br>汇编生成的`.obj`文件只有经过链接阶段将程序所引用的外部文件关联起来之后，形成`.exe`文件之后才可执行。程序中可能引用了定义在其他外部文件中的变量或者函数，比如某些库函数，而链接阶段所做的主要事情就是将这些相关联的文件链接起来，使得所有这些目标文件成为一个**能够被操作系统装入执行的统一的整体**。
<br><br>链接可分为动态链接和静态链接：
<br>动态链接：采用该链接方式表明，需要链接的代码是存放在**动态链接库或者某个共享对象的目标文件中**，链接程序(Link.exe)此时所做的只是在最终的可执行程序中**记录**下共享对象的名字和其他少量的登记信息，不会想需要链接的代码拷贝到最终的可执行程序中，
<br>在此可执行文件被执行时，动态链接库的全部内容将被**映射**到运行时相应进程的虚地址空间，动态链接程序将根据可执行程序中登记的信息找到相应的函数代码。
采用动态链接方式最终生成的**可执行程序较小**，因为不会将动态库中的内容拷贝到可执行程序中。但需要注意的是，可执行程序在**运行时需要目标主机上存在相应的动态库和环境**
<br>静态链接：采用该链接方式，需要链接的代码会被链接程序从相应的**静态链接库**中**拷贝**到可执行程序之中，在可执行程序运行时，这些代码会**装入**到该进程相应的地址空间之中。因此，采用静态链接库的方式，最终生成的**可执行文件相对较大**。

<br>参考：
<br> (1)https://blog.csdn.net/u010757264/article/details/50082925
<br> (2)https://blog.csdn.net/u011974126/article/details/47957503 

### 11. 双指针的使用
<br> (1)首先了解c++指针运算符（& *）
 - `&` :取地址运算符，返回操作数的内存地址
 - `*` :间接寻址运算符，返回操作数的所指地址的变量的值
<br> (2)双指针即指向指针的指针
- 本质：对传参解引用后得到原来的指针变量，且修改该指针的指向
- 应用：实现不确定返回值个数的编程方法

### 12.应用程序无法正常启动0xc000007b
主要原因可能是以下两种情况：
- 32位的工程调用64位的库。（x86程序配置了64位的dll）
- 64的工程调用32位的库。（x64程序配置了32位的dll）

### 13.visual studio打包部署程序
尤其使，把程序运行所需的所有dll库均打包进去，那么就涉及了怎么查找程序运行所依赖的所有动态库（系统动态库）的问题

### 14.自动生成读取/待写入文件的绝对路径

### 15.虚函数仅有声明无法通过编译
经推测：
非虚函数在声明时自动添加了body，
<br>但虚函数不会自动添加，需要自己添加body


### 16. 语法错误 : 缺少“;”(在“*”的前面) ，类似云云
双向依赖造成的

### 17.c++ newbie error C2512: no appropriate default constructor available，没有合适的默认构造函数可用
构造函数重载，空的默认构造函数需要定义

### 18. C++中public、protected、private的区别

### 19.宏的定义和使用
- 我们在写代码时在什么情况下会使用宏
- visual studio的工程属性宏;点击任意表单->edit->宏

### 20.substr使用常见误区


### 21.判断目录是否存在并创建
```
		//若目录savePath(string)不存在则创建
		if (_access(savePath.c_str(), 0) == -1)//.c_str()将string转const char*
		{
			_mkdir(savePath.c_str());
		}
```
注意：
<br>`_access()`需包含头文件`#include<io.h>`
<br>`_mkdir()`需包含头文件`#incldue<direct.h>`


### 22.静态库（`.lib`）与动态库(`.lib和.dll`)
https://www.cnblogs.com/hicjiajia/archive/2010/08/27/1809997.html

### 23.回调函数
https://www.zhihu.com/question/19801131

你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。回答完毕。

### 24.虚函数与回调、事件机制的使用
参考libevent
<br>https://www.cnblogs.com/neooelric/p/9057381.html
<br>http://senlinzhan.github.io/2017/08/12/libevent/
<br>https://aceld.gitbooks.io/libevent/content/

### 25.友元函数
这些函数不是类的一部分，但又需要频繁地访问类的数据成员
    <br>(1)友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend，其格式如下：
      <br> `friend 类型 函数名(形式参数);`
       <br>(2)友元函数的声明可以放在类的私有部分，也可以放在公有部分，它们是没有区别的，都说明是该类的一个友元函数。
      <br> (3)一个函数可以是多个类的友元函数，只需要在各个类中分别声明。
       <br>(4)友元函数的调用与一般函数的调用方式和原理一致。

<br>常用于运算符的重载
<br>例如：`friend std::ostream& operator<<(std::ostream& os, DataObjectBase& object)；`

原文链接：https://blog.csdn.net/fanyun_01/article/details/79122916

### 26.boost注意事项
boost库的版本需要与visual studio的相匹配，不然无法编译成功

### 27.visual studio无法编译登陆的问题
一般是代理问题，解决办法：
设置-》网络和Internet-》代理-》自动设置代理-》自动设置脚本，设置为关
<br>再次登陆即可