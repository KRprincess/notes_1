## OPENCV
### 1. cv::VideoWriter保存视频失败（0kb或打不开）
提示信息如
```
OpenCV: FFMPEG: tag 0x47504a4d / 'MJPG' is not supported with codec id 8 and format 'mp4 / MP4 (MPEG-4 Part 14)' 
OpenCV : FFMPEG : fallback to use tag 0x7634706d / 'mp4v'
```
一般是`.open(,fourcc,...)`第二个参数，编码格式设置不对，按照提示设置`CV_FOURCC('m','p', '4', 'v')`即可
<br>实例如：
```
cv::VideoWriter writer;
string savePath = "..../*.mp4";
...
writer.open(savePath, CV_FOURCC('m','p', '4', 'v'),fps, frameSize,true);
...
while(...)
{
       writer<<img;
}
writer.release();
...
```

## 2.将homographyMat转化为mapX,mapY供remap使用时注意事项
- remap中使用的mapX和mapY表示dst图像上对应在src上的坐标（目标点到源点的映射）
- warpPerspective使用的homography是源到目标的映射，与remap正好相反

## C++

### 1.为什么不能cout一个string
想使用operator<<需手动包含<string>头文件
<br>仅通过对<iostream>文件的包含，我们即可使用string和ostringstream等类，然而当我们想使用其成员函数时，需要包含其最终的实现版。`#include<sstream>`

### 2.如何理解.h文件和.cpp文件
https://blog.csdn.net/sinat_36053757/article/details/64444556

### 3.预处理（preprocessing）->编译（compilation）->汇编（assembly）->链接（linking）->执行（execution）
- 预处理/预编译(`->.i`)：gcc例子`gcc –E hello.c –o hello.i`
<br>预处理器在程序编译之前，将源程序中的宏定义、条件编译、头文件（源代码文件以“#”开始的预编译指令。比如“#include”、“#define”和条件预编译指令，如“#if”、“#ifdef”等。）包含指令以及特殊符号完成相应的替换工作(将所有的“#define”删除，展开所有的宏定义，并且替换掉“#include”。)。
<br> <1> 经过预处理后的程序，生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件。这些输出文件的含义与没有经过预处理的源文件是相同的，但内容有所不同
<br> <2>预编译头，就是把一个工程中要使用的一些标准头文件预先编译，以后该工程编译时，不再编译这部分头文件，仅仅使用预编译的结果。这样可以加快编译速度，节省时间。
<br>关于预编译头文件：
<br>预编译头文件通过编译`stdafx.cpp`生成，以工程名命名，由于预编译的头文件的后缀是“pch”，所以编译结果文件是`projectname.pch`。
<br>编译器通过一个头文件`stdafx.h`来使用预编译头文件。
<br>stdafx.h这个头文件名是可以在project的编译设置里指定的。
<br>编译器认为，所有在指令`#include "stdafx.h"`前的代码都是预编译的，它跳过#include "stdafx. h"指令，使用projectname.pch编译这条指令之后的所有代码。
<br>代码文件第一条语句都是：#include "stdafx.h"。在它前面的所有代码将被忽略，所以其他的头文件应该在这一行后面被包含

- 编译程序（`.i->.s`）：gcc例子`gcc -S hello.i -o hello.s`
<br>以预编译的输出作为输入，利用c++运行库，通过词法分析和语法分析，在确认所有指令都符合语法规则的情况时，将其翻译成等价的中间代码表示或汇编语言。 
<br>**编译是以源程序文件为单位单别编译的，头文件不参加编译。**

- 优化程序：
<br>一是对中间代码的优化，这种优化不依赖具体的计算机，同机器的硬件环境无关。主要的工作是删除公共表达式、循环优化(循环展开，自动向量化、循环不变量代码移动)以及无用赋值的删除等。
<br>另一种则主要针对目标代码的生成而进行的优化。此种优化同机器的硬件结构密切相关。最主要的是考虑如何充分利用机器的各个硬件寄存器存放有关的变量的值，以减少对于内存的访问次数

- 汇编程序(`.s->.obj`)：gcc例子`gcc –c hello.s –o hello.o`
<br>将编译、优化后的以汇编语言存在的程序转化为机器可识别的二进制代码，从而得到相应的目标文件（后缀`.obj`，不可执行）。目标文件通常由数据段和代码段组成。
<br>代码段保存的是程序的指令，该段一般是可读和可执行的，但一般是不可写的。
<br>数据段主要用来保存程序中所定义的或者需要用到的**全局变量、静态数据**(局部变量是在运行阶段生成)。数据段一般是可读可写的.

- 链接程序(`.obj->.exe`)：gcc例子`gcc hello.c -o hello.exe`
<br>汇编生成的`.obj`文件只有经过链接阶段将程序所引用的外部文件关联起来之后，形成`.exe`文件之后才可执行。程序中可能引用了定义在其他外部文件中的变量或者函数，比如某些库函数，而链接阶段所做的主要事情就是将这些相关联的文件链接起来，使得所有这些目标文件成为一个**能够被操作系统装入执行的统一的整体**。
<br><br>链接可分为动态链接和静态链接：
<br>动态链接：采用该链接方式表明，需要链接的代码是存放在**动态链接库或者某个共享对象的目标文件中**，链接程序(Link.exe)此时所做的只是在最终的可执行程序中**记录**下共享对象的名字和其他少量的登记信息，不会想需要链接的代码拷贝到最终的可执行程序中，
<br>在此可执行文件被执行时，动态链接库的全部内容将被**映射**到运行时相应进程的虚地址空间，动态链接程序将根据可执行程序中登记的信息找到相应的函数代码。
采用动态链接方式最终生成的**可执行程序较小**，因为不会将动态库中的内容拷贝到可执行程序中。但需要注意的是，可执行程序在**运行时需要目标主机上存在相应的动态库和环境**
<br>静态链接：采用该链接方式，需要链接的代码会被链接程序从相应的**静态链接库**中**拷贝**到可执行程序之中，在可执行程序运行时，这些代码会**装入**到该进程相应的地址空间之中。因此，采用静态链接库的方式，最终生成的**可执行文件相对较大**。

<br>参考：
<br> (1)https://blog.csdn.net/u010757264/article/details/50082925
<br> (2)https://blog.csdn.net/u011974126/article/details/47957503 

## cmake
<br>`cmake .. `  生成makefile
<br> `cmake --build .` 即make  (完成预编译-》编译-》优化=》汇编-》链接)
